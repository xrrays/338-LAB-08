# Generated by ChatGPT and D2L
# The following class was built on from Exercise 1.

# Union find is used to find cycles, needs find and union methods.
class UnionFind:                    #  Q2
    def __init__(self, size):
        self.parent = [i for i in range(size)]
        self.rank = [0 for _ in range(size)]

    def find(self, node):
        if self.parent[node] != node:
            self.parent[node] = self.find(self.parent[node])
        return self.parent[node]

    def union(self, node1, node2):
        root1 = self.find(node1)
        root2 = self.find(node2)

        if root1 != root2:
            if self.rank[root1] < self.rank[root2]:
                self.parent[root1] = root2
            elif self.rank[root1] > self.rank[root2]:
                self.parent[root2] = root1
            else:
                self.parent[root2] = root1
                self.rank[root1] += 1

class GraphNode:
    def __init__(self, data):
        self.data = data
        self.adjacent = {}  # key: GraphNode, value: weight

class Graph:
    def __init__(self):
        self.nodes = {}  # key: node data, value: GraphNode object
    
    def addNode(self, data):                        # exercise 1/2, implement basic methods
        if data not in self.nodes:
            new_node = GraphNode(data)
            self.nodes[data] = new_node
            return new_node
        return self.nodes[data]
    
    def removeNode(self, node):
        if node.data in self.nodes:
            del self.nodes[node.data]
            for n in self.nodes.values():
                if node in n.adjacent:
                    del n.adjacent[node]
    
    def addEdge(self, n1, n2, weight=1):
        if n1.data in self.nodes and n2.data in self.nodes:
            self.nodes[n1.data].adjacent[n2] = weight
            self.nodes[n2.data].adjacent[n1] = weight
    
    def removeEdge(self, n1, n2):
        if n1.data in self.nodes and n2.data in self.nodes:
            if n2 in self.nodes[n1.data].adjacent:
                del self.nodes[n1.data].adjacent[n2]
            if n1 in self.nodes[n2.data].adjacent:
                del self.nodes[n2.data].adjacent[n1]
    
    def importFromFile(self, file):                 # exercise 1/3, implement import function
        try:                                        # with format specifications
            with open(file, 'r') as f:
                content = f.read().strip()

            if not content.startswith('strict graph'):
                return None

            # Extracting the content inside the curly braces
            content = content[content.find('{') + 1:content.rfind('}')].strip()
            lines = content.split('\n')

            self.nodes.clear()  # Clear existing nodes and edges

            for line in lines:
                parts = line.strip().split('--')
                if len(parts) != 2:
                    return None  # Invalid edge format

                node1, rest = parts[0].strip(), parts[1].strip()
                node2, *weight_part = rest.replace('[', ' ').replace(']', ' ').split()
                weight = 1  # default weight

                if weight_part:
                    try:
                        weight = int(weight_part[1])
                    except ValueError:
                        return None  # Invalid weight value

                n1, n2 = self.addNode(node1), self.addNode(node2)
                if n2 in self.nodes[n1.data].adjacent:
                    return None  # Duplicate edge detected
                self.addEdge(n1, n2, weight)
    

        except Exception:
            return None
        
    def mst(self):                                  # Q3
        edges = []
        node_index = {node_data: index for index, node_data in enumerate(self.nodes)}
        uf = UnionFind(len(self.nodes))

        # Create an edge list
        for node_data, graph_node in self.nodes.items():
            for adj_node, weight in graph_node.adjacent.items():
                # To ensure each edge is only added once, add only if the node_data
                # has a lower index than adj_node.data in the node_index mapping
                if node_index[node_data] < node_index[adj_node.data]:
                    edges.append((node_data, adj_node.data, weight))

        # Sort the edges by weight
        edges.sort(key=lambda edge: edge[2])

        # Create a new graph to represent the MST
        mst_graph = Graph()
        for node_data in self.nodes:
            mst_graph.addNode(node_data)

        # Iterate over edges to create the MST using Kruskal's algorithm
        for node1_data, node2_data, weight in edges:
            node1_index = node_index[node1_data]
            node2_index = node_index[node2_data]
            if uf.find(node1_index) != uf.find(node2_index):
                uf.union(node1_index, node2_index)
                mst_graph.addEdge(mst_graph.nodes[node1_data], mst_graph.nodes[node2_data], weight)

        return mst_graph


