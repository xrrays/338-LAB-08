# Partly generated by ChatGPT and D2L, 
# The following class was built on from Exercise 1.

#1. Topological ordered can be implemented using the depth first algorithim. It is useful for this ordering
# because it keeps track of the order of the nodes, which is an essential part of topological order. The
# algorithim vists the deepest part of the graph before going backwards, satisfying the "each node must come
# after it's predecessor" condition of topological order.

class GraphNode:
    def __init__(self, data):
        self.data = data
        self.adjacent = {}  # key: GraphNode, value: weight

class Graph:
    def __init__(self):
        self.nodes = {}  # key: node data, value: GraphNode object
    
    def addNode(self, data):
        if data not in self.nodes:
            new_node = GraphNode(data)
            self.nodes[data] = new_node
            return new_node
        return self.nodes[data]
    
    def removeNode(self, node):
        if node.data in self.nodes:
            del self.nodes[node.data]
            for n in self.nodes.values():
                if node in n.adjacent:
                    del n.adjacent[node]
    
    def addEdge(self, n1, n2, weight=1):
        if n1.data in self.nodes and n2.data in self.nodes:
            self.nodes[n1.data].adjacent[n2] = weight
    
    def removeEdge(self, n1, n2):
        if n1 in self.nodes and n2 in self.nodes[n1].adjacent:
            del self.nodes[n1].adjacent[n2]
    
    def importFromFile(self, file):
        try:
            with open(file, 'r') as f:
                content = f.read().strip()

            if not content.startswith('strict graph'):
                return None

            content = content[content.find('{') + 1:content.rfind('}')].strip()
            lines = content.split('\n')

            self.nodes.clear()

            for line in lines:
                parts = line.strip().split('->')
                if len(parts) != 2:
                    return None

                node1, rest = parts[0].strip(), parts[1].strip()
                node2, *weight_part = rest.replace('[', ' ').replace(']', ' ').split()
                weight = 1

                if weight_part:
                    weight = int(weight_part[1])

                n1, n2 = self.addNode(node1), self.addNode(node2)
                self.addEdge(n1, n2, weight)
        except Exception:
            return None

    def isdag(self):
        visited = set()
        rec_stack = set()

        def dfs(node):
            visited.add(node)
            rec_stack.add(node)

            for neighbour in self.nodes[node].adjacent:
                if neighbour.data not in visited:
                    if not dfs(neighbour.data):
                        return False
                elif neighbour.data in rec_stack:
                    return False

            rec_stack.remove(node)
            return True
    
        for node_data in self.nodes:
            if node_data not in visited:
                if not dfs(node_data):
                    return False
        return True

    def toposort(self):
        if not self.isdag():
            return None

        visited = set()
        stack = []

        def dfs(node):
            visited.add(node)
            for neighbour in self.nodes[node].adjacent:
                if neighbour.data not in visited:
                    dfs(neighbour.data)
            stack.append(node)

        for node_data in self.nodes:
            if node_data not in visited:
                dfs(node_data)

        return stack[::-1]  # Return reversed stack
    
