#Partly generated by GPT and D2L

import time
import matplotlib.pyplot as plt

class GraphNode:
    def __init__(self, data):
        self.data = data
        self.adjacent = {}  # key: GraphNode, value: weight

class Graph:
    def __init__(self):
        self.nodes = {}  # key: node data, value: GraphNode object
    
    def addNode(self, data):                        
        if data not in self.nodes:
            new_node = GraphNode(data)
            self.nodes[data] = new_node
            return new_node
        return self.nodes[data]
    
    def removeNode(self, node):
        if node.data in self.nodes:
            del self.nodes[node.data]
            for n in self.nodes.values():
                if node in n.adjacent:
                    del n.adjacent[node]
    
    def addEdge(self, n1, n2, weight=1):
        if n1.data in self.nodes and n2.data in self.nodes:
            self.nodes[n1.data].adjacent[n2] = weight
            self.nodes[n2.data].adjacent[n1] = weight
    
    def removeEdge(self, n1, n2):
        if n1.data in self.nodes and n2.data in self.nodes:
            if n2 in self.nodes[n1.data].adjacent:
                del self.nodes[n1.data].adjacent[n2]
            if n1 in self.nodes[n2.data].adjacent:
                del self.nodes[n2.data].adjacent[n1]

    def importFromFile(self, file):                 # exercise 1/3, implement import function
        try:                                        # with format specifications
            with open(file, 'r') as f:
                content = f.read().strip()

            if not content.startswith('strict graph'):
                return None

            # Extracting the content inside the curly braces
            content = content[content.find('{') + 1:content.rfind('}')].strip()
            lines = content.split('\n')

            self.nodes.clear()  # Clear existing nodes and edges

            for line in lines:
                parts = line.strip().split('--')
                if len(parts) != 2:
                    return None  # Invalid edge format

                node1, rest = parts[0].strip(), parts[1].strip()
                node2, *weight_part = rest.replace('[', ' ').replace(']', ' ').split()
                weight = 1  # default weight

                if weight_part:
                    try:
                        weight = int(weight_part[1])
                    except ValueError:
                        return None  # Invalid weight value

                n1, n2 = self.addNode(node1), self.addNode(node2)
                if n2 in self.nodes[n1.data].adjacent:
                    return None  # Duplicate edge detected
                self.addEdge(n1, n2, weight)

        except Exception:
            return None
    
    def dfs(self, start_node):
        visited = set()
        order = []
        stack = [start_node]
        
        while stack:
            node = stack.pop()
            if node not in visited:
                visited.add(node)
                order.append(node.data)
                # In DFS, we want to add adjacent nodes in a way that the next node
                # to be visited is at the top of the stack, so we extend the left of the stack
                stack.extend(neighbour for neighbour in node.adjacent if neighbour not in visited)
        
        return order

class Graph2:
    def __init__(self):
        self.nodes = {}
        self.matrix = []
    
    def addNode(self, data):
        if data not in self.nodes:
            new_node = GraphNode(data)
            self.nodes[data] = new_node
            # Adjust the size of the matrix to accommodate the new node
            for row in self.matrix:
                row.append(0)
            self.matrix.append([0] * len(self.nodes))
            return new_node
        return self.nodes[data]
    
    def removeNode(self, node):
        if node.data in self.nodes:
            del self.nodes[node.data]
            for n in self.nodes.values():
                if node in n.adjacent:
                    del n.adjacent[node]
    
    def addEdge(self, n1, n2, weight=1):
        if n1.data in self.nodes and n2.data in self.nodes:
            idx1, idx2 = list(self.nodes).index(n1.data), list(self.nodes).index(n2.data)
            self.matrix[idx1][idx2] = weight
            self.matrix[idx2][idx1] = weight

    def removeEdge(self, n1, n2):
        if n1.data in self.nodes and n2.data in self.nodes:
            if n2 in self.nodes[n1.data].adjacent:
                del self.nodes[n1.data].adjacent[n2]
            if n1 in self.nodes[n2.data].adjacent:
                del self.nodes[n2.data].adjacent[n1]

    def importFromFile(self, file):                 # exercise 1/3, implement import function
        try:                                        # with format specifications
            with open(file, 'r') as f:
                content = f.read().strip()

            if not content.startswith('strict graph'):
                return None

            # Extracting the content inside the curly braces
            content = content[content.find('{') + 1:content.rfind('}')].strip()
            lines = content.split('\n')

            self.nodes.clear()  # Clear existing nodes and edges

            for line in lines:
                parts = line.strip().split('--')
                if len(parts) != 2:
                    return None  # Invalid edge format

                node1, rest = parts[0].strip(), parts[1].strip()
                node2, *weight_part = rest.replace('[', ' ').replace(']', ' ').split()
                weight = 1  # default weight

                if weight_part:
                    try:
                        weight = int(weight_part[1])
                    except ValueError:
                        return None  # Invalid weight value

                n1, n2 = self.addNode(node1), self.addNode(node2)
                if n2 in self.nodes[n1.data].adjacent:
                    return None  # Duplicate edge detected
                self.addEdge(n1, n2, weight)

        except Exception:
            return None
    
    def dfs(self, start_node_data):
        visited = set()
        order = []
        stack = [self.nodes[start_node_data]]
        
        while stack:
            node = stack.pop()
            if node.data not in visited:
                visited.add(node.data)
                order.append(node.data)
                idx = list(self.nodes).index(node.data)
                # Checking the matrix for adjacent nodes and adding them to the stack
                for i, connected in enumerate(self.matrix[idx]):
                    if connected != 0 and list(self.nodes.values())[i].data not in visited:
                        stack.append(list(self.nodes.values())[i])
        
        return order


# Measuring performance of dfs
def measure_performance(graph, start_node_data, use_matrix=False):
    times = []
    for _ in range(10):
        start_time = time.perf_counter()  # Using a high-resolution timer
        if use_matrix:
            graph.dfs(start_node_data)
        else:
            start_node = graph.nodes[start_node_data]
            graph.dfs(start_node)
        end_time = time.perf_counter()
        times.append(end_time - start_time)
    return times

graph = Graph()
graph2 = Graph2()
graph.importFromFile('random.dot')
graph2.importFromFile('random.dot')

start_node_data = '0' 
start_node = graph.addNode(start_node_data)
graph2.addNode(start_node_data)

# Measure performance
graph_dfs_times = measure_performance(graph, start_node_data)
graph2_dfs_times = measure_performance(graph2, start_node_data, use_matrix=True)
graph_stats = (max(graph_dfs_times), min(graph_dfs_times), sum(graph_dfs_times) / len(graph_dfs_times))
graph2_stats = (max(graph2_dfs_times), min(graph2_dfs_times), sum(graph2_dfs_times) / len(graph2_dfs_times))

print(f"Graph DFS - Max: {graph_stats[0]}, Min: {graph_stats[1]}, Avg: {graph_stats[2]}")
print(f"Graph2 DFS - Max: {graph2_stats[0]}, Min: {graph2_stats[1]}, Avg: {graph2_stats[2]}")
if graph_stats[2] < graph2_stats[2]:
    print("The adjacency list implementation (Graph) has a faster average DFS execution time than the adjacency matrix implementation (Graph2).")
else:
    print("The adjacency matrix implementation (Graph2) has a faster average DFS execution time than the adjacency list implementation (Graph).")


# Exercise 4 Part 3)

# The adjacency matrix implementation is faster. This is likely because the graph being tested has a high number of
# edges, which the adjacency matrix implementation tends to perform better with. 

