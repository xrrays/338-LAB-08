#generated by gpt and d2l

class GraphNode:
    def __init__(self, data):
        self.data = data
        self.adjacent = {}  # key: GraphNode, value: weight

class Graph:
    def __init__(self):
        self.nodes = {}  # key: node data, value: GraphNode object
    
    def addNode(self, data):                        # exercise 1/2, implement basic methods
        if data not in self.nodes:
            new_node = GraphNode(data)
            self.nodes[data] = new_node
            return new_node
        return self.nodes[data]
    
    def removeNode(self, node):
        if node.data in self.nodes:
            del self.nodes[node.data]
            for n in self.nodes.values():
                if node in n.adjacent:
                    del n.adjacent[node]
    
    def addEdge(self, n1, n2, weight=1):
        if n1.data in self.nodes and n2.data in self.nodes:
            self.nodes[n1.data].adjacent[n2] = weight
            self.nodes[n2.data].adjacent[n1] = weight
    
    def removeEdge(self, n1, n2):
        if n1.data in self.nodes and n2.data in self.nodes:
            if n2 in self.nodes[n1.data].adjacent:
                del self.nodes[n1.data].adjacent[n2]
            if n1 in self.nodes[n2.data].adjacent:
                del self.nodes[n2.data].adjacent[n1]
    
    def importFromFile(self, file):                 # exercise 1/3, implement import function
        try:                                        # with format specifications
            with open(file, 'r') as f:
                content = f.read().strip()

            if not content.startswith('strict graph'):
                return None

            # Extracting the content inside the curly braces
            content = content[content.find('{') + 1:content.rfind('}')].strip()
            lines = content.split('\n')

            self.nodes.clear()  # Clear existing nodes and edges

            for line in lines:
                parts = line.strip().split('--')
                if len(parts) != 2:
                    return None  # Invalid edge format

                node1, rest = parts[0].strip(), parts[1].strip()
                node2, *weight_part = rest.replace('[', ' ').replace(']', ' ').split()
                weight = 1  # default weight

                if weight_part:
                    try:
                        weight = int(weight_part[1])
                    except ValueError:
                        return None  # Invalid weight value

                n1, n2 = self.addNode(node1), self.addNode(node2)
                if n2 in self.nodes[n1.data].adjacent:
                    return None  # Duplicate edge detected
                self.addEdge(n1, n2, weight)

        except Exception:
            return None

        return self

    def dfs(self, start_node):
        """Performs a depth-first search traversal starting from a given node."""
        visited = set()
        traversal_order = []

        def dfs_helper(node):
            visited.add(node)
            traversal_order.append(node)
            for neighbor in self.adj_list[node]:
                if neighbor not in visited:
                    dfs_helper(neighbor)
                dfs_helper(start_node)
                return traversal_order


class Graph2:
  """
  This class represents a graph using an adjacency matrix.
  """
  def __init__(self, num_vertices):
    """
    Initializes the graph with a given number of vertices.
    """
    self.num_vertices = num_vertices
    self.adj_matrix = [[0 for _ in range(num_vertices)] for _ in range(num_vertices)]

  def add_node(self, data):
    """
    This method is not applicable for adjacency matrix representation. 
    Nodes are implicitly created when edges are added.
    """
    pass

  def remove_node(self, node):
    """
    This method is not directly applicable for adjacency matrix representation.
    Removing all edges connected to the node and potentially re-indexing the matrix
    would be required for a complete implementation.
    """
    pass

  def add_edge(self, n1, n2, weight=1):
    """
    Adds an edge between two vertices (represented by their indices) with a weight.
    """
    if 0 <= n1 < self.num_vertices and 0 <= n2 < self.num_vertices:
      self.adj_matrix[n1][n2] = weight
      self.adj_matrix[n2][n1] = weight  # For undirected graphs
    else:
      print("Invalid vertex index")

  def remove_edge(self, n1, n2):
    """
    Removes the edge between two vertices (represented by their indices).
    """
    if 0 <= n1 < self.num_vertices and 0 <= n2 < self.num_vertices:
      self.adj_matrix[n1][n2] = 0
      self.adj_matrix[n2][n1] = 0  # For undirected graphs
    else:
      print("Invalid vertex index")

  def print_graph(self):
    """
    Prints the adjacency matrix representation of the graph.
    """
    for row in self.adj_matrix:
      print(row)

  def importFromFile(self, file):
    """
    This function attempts to import a graph from a file with the format:

    strict graph G {
        0 -- 557	[weight=45];
        1 -- 306	[weight=26];
        ... (other edges)
    }

    Nodes are implicitly defined by their position in the matrix.
    Weights are assumed to be non-negative integers.
    """
    # Open the file for reading
    try:
        with open(file, 'r') as f:
            lines = f.readlines()
    except FileNotFoundError:
        print("Error: File not found!")
        return

    # Skip the first two lines (header)
    lines = lines[2:]

    # Get the number of vertices from the first line (assuming format is valid)
    num_vertices = int(lines[0].split()[0])
    self.num_vertices = num_vertices

    # Initialize the adjacency matrix with zeros
    self.adj_matrix = [[0 for _ in range(num_vertices)] for _ in range(num_vertices)]

    # Iterate through remaining lines, parsing edges and weights
    for line in lines:
        # Split the line by whitespace (assuming space separated elements)
        parts = line.strip().split()

        # Extract start and end node indices and weight (handle potential errors)
        try:
            start_index = int(parts[0])
            end_index = int(parts[2].split("=")[1])
            weight = int(parts[3].split("=")[1])
            if weight < 0:
                print("Error: Weight cannot be negative!")
                continue
        except (IndexError, ValueError):
            print("Error: Invalid line format in file!")
            continue
        
        # Ensure indices are within valid range
        if not (0 <= start_index < num_vertices and 0 <= end_index < num_vertices):
            print("Error: Invalid vertex index!")
            continue

        # Update the adjacency matrix for the edge with weight
        self.adj_matrix[start_index][end_index] = weight
        self.adj_matrix[end_index][start_index] = weight  # For undirected graphs

    def dfs(self, start_node):
        visited = set()
        traversal_order = []

        def dfs_helper(node):
            visited.add(node)
            traversal_order.append(node)
            for neighbor in range(self.num_vertices):
                if self.adj_matrix[node][neighbor] == 1 and neighbor not in visited:
                    dfs_helper(neighbor)

        dfs_helper(start_node)
        return traversal_order
    
import timeit

# Sample Graph and Graph2 creation (replace with your actual data)
graph = Graph()  # Create a Graph object with your data
graph2 = Graph2()  # Create a Graph2 object with your data

graph.importFromFile("random.dot")
graph2.importFromFile("random.dot")

start_node = 0  # Starting node for DFS

# Define functions for timing DFS in each class
def time_graph_dfs():
  return timeit.timeit(lambda: graph.dfs(start_node), number=10)

def time_graph2_dfs():
  return timeit.timeit(lambda: graph2.dfs(start_node), number=10)

# Run timing and collect results
graph_dfs_times = timeit.repeat(time_graph_dfs, repeat=3, number=10)
graph2_dfs_times = timeit.repeat(time_graph2_dfs, repeat=3, number=10)

# Calculate statistics for each implementation
print("Graph DFS:")
print(f"  Maximum time: {max(graph_dfs_times):.6f} seconds")
print(f"  Minimum time: {min(graph_dfs_times):.6f} seconds")
print(f"  Average time: {sum(graph_dfs_times) / len(graph_dfs_times):.6f} seconds")

print("\nGraph2 DFS:")
print(f"  Maximum time: {max(graph2_dfs_times):.6f} seconds")
print(f"  Minimum time: {min(graph2_dfs_times):.6f} seconds")
print(f"  Average time: {sum(graph2_dfs_times) / len(graph2_dfs_times):.6f} seconds")